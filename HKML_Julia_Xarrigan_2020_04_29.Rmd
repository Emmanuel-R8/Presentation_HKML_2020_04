---
title: "Introduction to Julia"
subtitle: "Data Science and Machine Learning"
author: "Emmanuel Rialland"
date: "April, 29th 2020"
output:
  xaringan::moon_reader:
    css: [default, fc, fc-fonts]
    yolo: FALSE
    chakra: libs/remark-latest.min.js
    lib_dir: libs
    logo: Julia_logo.svg
    nature:
      ratio: '16:9'
      navigation: 
        click: TRUE
      highlightStyle: github
      highlightLines: yes
      countIncrementalSlides: no
mathjax: true
---

```{r include=FALSE}

knitr::opts_chunk$set(
#  class.source = "numberLines lineAnchors",
#  class.output = c("numberLines lineAnchors chunkout")
)

options(htmltools.dir.version = FALSE)
options(servr.daemon = TRUE)

JuliaCall::julia_markdown_setup(JULIA_HOME = "/opt/julia/bin", notebook = TRUE)
```


--- 

# Plan for today

- What is Julia and short comparison

--

- Data Science - COVID 19 as an example

--

- Machine Learning - the Julia Flux.jl library

---
class: inverse, center, middle

# What is Julia?

---
# High-level features

**Easy to use**: Julia has high level syntax, making it an accessible language for programmers from any background or experience level. 

--

**Dynamic**: Julia is dynamically-typed, feels like a scripting language, and has good support for interactive use.

--

**Optionally typed**: Julia has a rich language of descriptive datatypes, and type declarations can be used to clarify and solidify programs.

--

**General**: Julia uses multiple dispatch as a paradigm, making it easy to express many object-oriented and functional programming patterns. 

--

**Julia is fast!**: Julia was designed from the beginning for high performance. Julia programs compile to efficient native code for multiple platforms via LLVM.

--

**Open source**: Julia is provided under the MIT license, free for everyone to use. All source code is publicly viewable on GitHub.

---
# Why We Created Julia 

## (from the authors)

We want a language that's __open source__, with a liberal license. We want the __speed of C__ with the __dynamism of Ruby__. We want a language that's homoiconic, with __true macros like Lisp__, but with __obvious, familiar mathematical notation like Matlab__. We want something as usable for __general programming as Python__, as easy for __statistics as R__, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.

(Did we mention it should be as fast as C?)

We never want to mention types when we don't feel like it. But when we need __polymorphic functions__, we want to use __generic programming__ to write an algorithm just once and apply it to an infinite lattice of types; we want to use __multiple dispatch__ to efficiently pick the best method for all of a function's arguments, from dozens of method definitions, providing common functionality across drastically different types. Despite all this power, we want the language to be __simple and clean__.

_Source: [https://julialang.org/blog/2012/02/why-we-created-julia/](https://julialang.org/blog/2012/02/why-we-created-julia/)_

## And they did it!

---
# Easy to use

- Interactive REPL like Python or R. Julia is the _Ju_ in Jupyter

- Your preferred IDE supports it. Atom is the most mature, but VS Code, VIM, Emacs, SublimeText work fine. This presentation is made with RStudio.

- Great community active and helpful on Discourse and Slack.



---
# It is fast - (Old) Benchmark

![Simple benchmark](Julia_benchmarks.png)

_Julia v1.0.0, SciLua v1.0.0-b12, Rust 1.27.0, Go 1.9, Java 1.8.017, Javascript V8 6.2.414.54, Matlab R2018a, Python 3.6.3 (NumPy v1.14.0), R 3.5.0, and Octave 4.2.2. C and Fortran are compiled with gcc 7.3.1. See [https://julialang.org/benchmarks/]()_

---
class: inverse, center, middle

# Fast means _really_ fast

## `LoopVectorization.jl`

(Recent library, pure Julia, available on any platform supported by LLVM)

---
# Matrix multiplication

![](LV_MatrixMultiplication.small.png)

---
# Matrix-vector multiplication

![](LV_MatrixVector.small.png)
---
# Sum-squared error

![](LV_SumSquaredError.small.png)


---
# Image kernel convolution

![](LV_ImageConvolKnownKernelSize.small.png)



---
# No cheating - unknown kernel size at compile time

![](LV_ImageConvolUnknownKernelSize.small.png)

---
class: center
# It is also pretty!

![Lorenz Attractor](Lorenz_Attractor.gif)
[https://docs.juliaplots.org/](https://docs.juliaplots.org/latest/)

---
# Code walk

.pull-left-25[
$\frac{dx}{dt} = \sigma (y - x)$       $\frac{dy}{dt} = x (\rho - z) - y$      $\frac{dz}{dt} = x y - \beta z$
]

.pull-right-75[
```{julia eval=FALSE,cache=FALSE}
using Plots

# define a structure to gather the Lorenz attractor's parameters
Base.@kwdef mutable struct LorenzAttractor
    x::Float64 = 1;         y::Float64 = 1;         z::Float64 = 1;
    σ::Float64 = 10;        ρ::Float64 = 28;        β::Float64 = 8/3;   dt::Float64 = 0.02
end

# 'l' is an instance of the Lorenz structure
l = LorenzAttractor()

function step!(l::LorenzAttractor)
    dx = l.σ * (l.y - l.x); dy = l.x * (l.ρ - l.z) - l.y;  dz = l.x * l.y - l.β * l.z;
    l.x += l.dt * dx;       l.y += l.dt * dy;              l.z += l.dt * dz
end

# initialize a 3D plot with 1 empty series
plt = plot3d(1, title = "Lorenz Attractor", marker = 2,
                xlim = (-30, 30),   ylim = (-30, 30),   zlim = (0, 60))

# build an animated gif by pushing new points to the plot, saving every 10th frame
@gif for i=1:1500
    step!(l)                          # Calculate the next point
    push!(plt, l.x, l.y, l.z)         # Add that point to the plot
end every 10
```
]



---
# Syntax Shootout

$$
\begin{align}
a, b &\in \mathbb{R} \\
A,B &\in \mathbb{R}^{m \times n} 
\end{align}
$$

$$
aA + bB
$$

.pull-left-50[
## Python (and Numpy)

```
import numpy
A = B = [[1, 2], [3, 4]]

# 2.A + 3.B
numpy.add(numpy.multiply(2, A), 
          numpy.multiply(3, B))
```
]

.pull-right-50[
## Julia

```
A = B = [1 2; 3 4]
2 * A + 3 * B
```

or better looking

```
Γ = Λ = [1 2; 3 4]
2 * Γ + 3 * Λ
```
]


---
# Typing and Multiple dispatch example: addition (1/2)

## Julia first compiles to LLVM


.pull-left-50[
```{julia eval=FALSE,cache=FALSE}
function add(x::Int64, y::Int64)::Int64
  return x + y
end


@code_llvm add(1, 2)

# define i64 @julia_add_18857(i64, i64) {
# top:
#   %2 = add i64 %1, %0
#   ret i64 %2
# }
```
]

--

.pull-right-50[
```{julia eval=FALSE,cache=FALSE}
function add(x::Float64, y::Float64)::Float64
  return x + 2.0 * y
end;


@code_llvm add(1.0, 2.0)

# define double @julia_add_18854(double, double) {
# top:
#  %2 = fmul double %1, 2.000000e+00
#  %3 = fadd double %2, %0
# ret double %3
# }
```
]

---
# Typing and Multiple-dispatch example: addition (2/2)

## Then LLVM to Assembly


.pull-left-50[
```{julia eval=FALSE,cache=FALSE}
function add(x::Int64, y::Int64)::Int64
  return x + y
end;


@code_native add(1, 2)

#   leaq    (%rdi,%rsi), %rax
#   retq
#   nopw    %cs:(%rax,%rax)
#   nop
```
]

--

.pull-right-50[
```{julia eval=FALSE,cache=FALSE}
function add(x::Float64, y::Float64)::Float64
  return x + 2.0 * y
end;


@code_native add(1.0, 2.0)

#     vaddsd  %xmm1, %xmm1, %xmm1
#     vaddsd  %xmm0, %xmm1, %xmm0
#   retq
#   nopl    (%rax)
```
]

---
# Just Ahead of Time compilation 

```{julia}
length(methods(+))
```


```{julia}
@show first(methods(+))
```

---
# Typing

- Julia has a whole zoo of different types: Primitive, Abstract vs. Concrete, Immutable vs. Mutable Composite, Union, Parametric, Aliases...

- Key points:

  - Dynamic typing when early development, strong typing to catch bugs later.

  - High-level code is easy to express with Abstract and Parametric types: 
  
    - `Int64` is a subtype of `Integer`, and `Float`  is a subtype of `AbstractFloat`, which are subtypes of `Number`.
    
    - You can have `Matrix(Float64)` or `Matrix{Int64}`
  
  - Sub-typing (and generic functions) allows easy algorithmic specialisation and high speed
  
    - Easy to specialise on `DenseArray` or `SparseArray` for specific algorithms, and default on generic algorithms for others (just an example).
  

---
# Generic function / Multiple dispatch 

- Generic functions (Common Lisp, R S3, R S4) - Not message passing (e.g. Java, C++, Python, R Reference Classes and S6)

- Multiple dispatch on the entire type signature of the method (Common Lisp, R S4), not just on the first one (e.g. R S3, Python)

- Better at code reuse than message-passing OO:

  - No need to sub-class: no new class, can provide completely different representation.
  
  - No need to reimplement all methods.

- Recommended viewing: _The Unreasonable Effectiveness of Multiple Dispatch_ by Stefan Karpinski

---
class: inverse, center, middle

# Data science with COVD19 

---
# Background

This part is about fitting a model to a set of data. It is not machine learning is the sense of guessing a model that best fits data.

It was born after reading a report from Imperial College London and viewing a forecasting model by [NeherLab](https://neherlab.org/covid19/). 


There are 4 types of epidemiological models:

- **Agent-based models** simulate a population that mimics a real population. The disease is then propagated via agents through the simulated population. Stochastic simulation.

- **Machine learning/regression models** are models that learn historical patterns and leverage those patterns for forecasting. This group includes such approaches as statistical time series, linear or regularized regression, clustering, and nonparametric approaches, often characterized by the absence of a mechanistic model.

- **Mechanistic models** are differential-equation model descriptions of the disease transmission mechanism. They include a class of models referred to as compartmental models that partition a population into compartments and mathematically describe how individuals in the population move between compartments.

- **Data-assimilation/dynamic models** usually involve embedding a mechanistic model into a probabilistic framework, allowing for the explicit modeling of the disease transmission process and observational noise with stochastic and/or Bayesian formalism. That is, the dynamic modeling approach combines two sources of uncertainty in the modeling; parametric uncertainty in the mechanistic model and random uncertainty in the observations.

---
# Overview

The **mechanistic** model works as follows:

- susceptible individuals are exposed and infected through contact with contagious individuals. Each contagious individual causes on average $R_0$ new infections.

- Transmissibility of the virus could have seasonal variation which is parameterised with the parameter “seasonal forcing” (amplitude) and “peak month” (month of most active transmission).

- Exposed individuals progress through sequential conditions after an average latency: asymptomatic $\rightarrow$ symptomatic  $\rightarrow$ severe $\rightarrow$ critical $\rightarrow$ death. At each stage, an individual can recover.


---
# Age cohorts

- The proportion/probability of passing from condition to condition depends on age

- COVID-19 is much more severe in the elderly and proportion of elderly in a community is therefore an important determinant of the overall burden on the health care system and the death toll. We collected age distributions for many countries from data provided by the UN and make those available as input parameters. Furthermore, we use data provided by the epidemiology group by the Chinese CDC to estimate the fraction of severe and fatal cases by age group.


# Infrastructure

- Hospital beds and ICU units are limited.

- The probability of a condition becoming more severe is increased if appropriate care is not available: being in critical condition at home vs. in an ICU unit.

---
# Compartments

![](Compartments.small.png)

---
# Transition rates

![](Transitions.svg)
---
# Initial results for Italy

![](DeathsForecast.png)

---
# Bed usage

![](BedUsage.png)

---
# Before optimisation

![](Vignette1.png)


---
# After 3 minute optimisation

![](Vignette2.png)

---
# Code samples

```{julia eval=FALSE,cache=FALSE}
### Define a model as an Ordinary Differential Equation
### epiDynamics! defines the stepwise evolution:
###    function epiDynamics!(dP, P, params, t)

using DifferentialEquations
model = ODEProblem(epiDynamics!, P0, tSpan, parameters);

sol = solve(model, Tsit5(); progress = false, progress_steps = 5);


# Load the Blackbax optimisation library
using BlackBoxOptim
result = bboptimize(p -> singleCountryLoss(country, DiseaseParameters, p), 
                    SearchRange = countryRange;
                    Method = :adaptive_de_rand_1_bin, 
                    MaxTime = maxtime, 
                    TargetFitness = 2.0)


```

The actual code is available on Github.

---
# Limitations

- This is just a model. The map is not the territory.

- Modelling the effect of social measures / different countries

- Herd effect

- More compartments (post-recovery contagion)

- Bayesian approach and probabilistic models account better for incremental information


---
class: inverse, center, middle

# The `Flux.jl` machine learning library

Machine Learning Stack

---
# What is differentiable programming?

- Deep learning speed improvement heavily have heavily relied on the introduction of automatic differentiation (calculation of a derivative at the cost of a simgle function call). This is provided by the `Zygote.jl` library. 

- This is restricted to the differentiation of mathematic formulas.

- `Flux` adds algorithmic differentiation: for example `for` loops, `if` statements. This dramatically extends the universe of possibilities.

- `Flux` also easily offloads calculation to GPUs or TPUs (Google's tensor processing units).

- `Flux` small (few 1,000's of lines compared to millions for TF and PyTorch) and written in a single language (no Python, C, C++...)

---
# Examples

- Perceptron is a simple formula: optimise $Loss(y - \hat{y})$ for $y = \sigma(W . x + b)$. Autodiff is enough.

But this doesn't work for richer models:

- Image recognition with detailed physical model of lenses.

- X-Ray images feeding into a pharmacokinetics model to optimise drug dosage.

- Self-driving car with realistic physical of car of various road conditions.  
 
- Example: Body movement



![](DiffProg.png)


---
# Code samples


.pull-left-50[
```{julia eval=FALSE,cache=FALSE}
using Zygote, Flux

dense(W, b, σ = identity) = x -> σ.(W * x .+ b)

chain(f...) = foldl(∘, reverse(f))

mlp = chain(
    dense(randn(5, 10), randn(5), tanh), 
    dense(randn(2, 5), randn(2)))

x = rand(10)

δm = gradient(mlp) do m
    sum(m(x))
end

# Gradient descent
m -= η * δm 
```
]

--

.pull-right-50[
## Let's add calls to `Cuda` and `Python`

```{julia eval=FALSE,cache=FALSE}
using CuArrays

cuda() do
    δm = Zygote.gradient(mlp) do m
        sum(m(x))
    end
end
```

```
using PyCall

py"""
  import torch.nn.functional as F
  def foo(W, b, x):
      return F.sigmoid(W @ x + b)
"""

δW, δb = gradient(W, b do W, b) do
    sum( (foo(W, b, x) .- [0.0, 1.0]).^2 )
end
```
]


---
# Metalhead

## For computer vision models, see `Metalhead.jl`

.pull-left-60[
```{julia eval=FALSE,cache=FALSE}
using Metalhead
using Metalhead: classify

vgg = VGG19()
img = "Dog.jpg"


vgg.layers

# Chain(Conv((3, 3), 3=>64, relu), 
#       Conv((3, 3), 64=>64, relu), 
#       MaxPool((2, 2), pad = (0, 0, 0, 0), 
#       stride = (2, 2)), 
#       .....
#       Dense(25088, 4096, relu), Dropout(0.5), 
#       Dense(4096, 4096, relu), Dropout(0.5), 
#       Dense(4096, 1000), softmax))
```
]

.pull-right-40[

_(This is a random Internet dog...)_

![](Dog.jpg)

```
Result: "Labrador retriever
```
]




---
# Thanks and links

NeherLab: https://neherlab.org/covid19/

Julia: [https://julialang.org]()

FluxML: [https://fluxml.ai/]()

LoopVectorization: [https://chriselrod.github.io/LoopVectorization.jl/latest/]()

[https://fluxml.ai/2019/02/07/what-is-differentiable-programming.html]()

Youtube channel: [https://www.youtube.com/user/JuliaLanguage]()

*** 

**References**:

_JuliaCon 2019 | The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski_ [https://www.youtube.com/watch?v=kc9HwsxE1OY]()

Osthus, D., Gattiker, J., Priedhorsky, R., & Del Valle, S. Y. (2019). _Dynamic Bayesian influenza forecasting in the United States with hierarchical discrepancy (with discussion)_. Bayesian Analysis, 14(1), 261-312.

*** 

Written in **RStudio** in [R Markdown]([https://rmarkdown.rstudio.com]())

Slides created via the R package [**xaringan**]([https://github.com/yihui/xaringan]()).

(C) Emmanuel Rialland - [Emmanuel-R8.github.io]() & [www.linkedin.com/in/emmanuelrialland]()


